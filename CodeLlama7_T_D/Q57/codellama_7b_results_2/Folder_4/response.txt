 ```
import numpy as np
def submatrix_with_particular_sum(matrix):
    # Initialize an empty list to store the submatrices
    submatrices = []

    # Loop through each row of the matrix
    for i in range(matrix.shape[0]):
        # Loop through each column of the matrix
        for j in range(matrix.shape[1]):
            # Initialize a variable to store the sum of all integers in the submatrix
            submatrix_sum = 0

            # Loop through each element of the submatrix
            for row in range(i, i + 3):
                for col in range(j, j + 3):
                    # Add the current element to the sum
                    submatrix_sum += matrix[row][col]

                    # Check if the sum equals 87. If it does, add the submatrix to the list and break out of the inner loop
                    if submatrix_sum == 87:
                        submatrices.append(matrix[i:i + 3][j:j + 3]])
                        break

            # Check if the sum equals 87. If it does, add the submatrix to the list and break out of the outer loop
            if submatrix_sum == 87:
                break

    return submatrices

# Test the function with a sample matrix
matrix = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
#print(submatrix_with_particular_sum(matrix))
```
This code uses nested loops to iterate through each row and column of the given matrix. It then initializes an empty list to store the submatrices that meet the specified criteria.
The code first loops through each row of the matrix, starting from the topmost row. For each row, it then loops through each column of the matrix, starting from the leftmost column.
For each element of the current submatrix, the code calculates the sum of all integers in the submatrix. It then checks if the sum equals 87. If it does, the code adds the submatrix to the list of submatrices and breaks out of both loops.
If no such submatrix is found, the code returns an empty list.